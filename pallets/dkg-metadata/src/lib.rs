// Copyright 2022 Webb Technologies Inc.
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
// http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

//! # DKG Metadata Module
//!
//! A pallet to manage metadata about the DKG and DKG proposal system.
//!
//! ## Overview
//!
//! The DKG Metadata pallet manages the following metadata about the DKG and DKG proposal system:
//! - The active DKG public key
//! - The active DKG authorities
//! - The next DKG public key
//! - The next DKG authorities
//! - The DKG signature threshold (the `t` in `t-out-of-n` threshold signatures)
//! - The key refresh process
//! - The misbehavior reporting process
//!
//! The pallet tracks authority changes after each session and updates the metadata for the
//! current and next authority sets respectively. The pallet also exposes a way for the root origin
//! to update the signature threshold used in the DKG signing system.
//!
//! The pallet is responsible with initiating the key refresh process for rotating the DKG keys
//! across authority set changes and executing the rotation when a new session starts.
//!
//! The pallet tracks reputations of DKG authorities by providing extrinsics and storage for
//! submitting misbehaviour reports about authorities that misbehave.
//!
//! ### Terminology
//!
//! - **Authority**: A DKG authority.
//! - **Authority Set**: A set of DKG authorities.
//! - **Active DKG public key**: The public key of the DKG protocol that is currently active.
//! - **Next DKG public key**: The public key of the DKG protocol that will be active after the next
//!   authority set change.
//! - **DKG signature threshold**: The `t` in `t-out-of-n` threshold signatures used in the DKG
//!   signing system.
//! - **Misbheaviour Report**: A report of a DKG authority misbehaving.
//! - **Refresh delay**: The length of time within a session that the key refresh protocol will be
//!   initiated.
//!
//! ### Implementation
//!
//! The pallet is implemented to track and maintain a variety of different pieces of data. It is the
//! primary pallet used to store the active and next DKG public keys that are generated by the
//! active and next authorities of the underlying blockchain protocol. A runtime API is used to
//! expose the active and next authorities to the external workers responsible with executing the
//! DKG and signing protocol.
//!
//! The pallet exposes a variety of extrinsics for updating metadata:
//! - `set_threshold`: Allows a root-origin to update the DKG signature threshold used in the
//!   threshold signing protocol.
//! - `set_refresh_delay`: Allows a root-origin to update the delay before the key refresh process
//!   is initiated.
//! - `submit_misbehaviour_reports`: Allows authorities to submit misbehaviour reports. Once the
//!   `threshold` number of reports is submitted, the offending authority will lose reputation.
//! - `submit_public_key`: Allows submitting of the genesis public key by the initial authorities of
//!   the DKG protocol.
//! - `submit_next_public_key`: Allows submitting of the next public key by the next authorities of
//!   the DKG protocol.
//! - `submit_public_key_signature`: Allows submitting of the signature of the next public key by
//!   the active DKG key for eventual rotation.
//!
//! The refresh process is initiated `T::RefreshDelay` into each session. A RefreshProposal is
//! created and sent directly to the `pallet-dkg-proposal-handler` for inclusion into the unsigned
//! proposal queue and soon after for signing. Once this proposal is signed, the signature is posted
//! back on-chain to this pallet which rotates the DKG keys when the session ends.
//!
//! The misbehaviour reporting process relies on a honest-threshold assumption. When DKG authorities
//! misbehave offchain, any detecting authority can submit a report of the offending authority. If a
//! `threshold` number of reports is submitted, then the offending authority will lose reputation.
//! This reputation map is utilized by each DKG authority to ensure every authority can generate a
//! deterministic signing set for the threshold signing protocols. The signing set is taken to
//! initially be the top `t` DKG authorities by reputation.
//!
//! ## Related Modules
//!
//! * [`System`](https://github.com/paritytech/substrate/tree/master/frame/system)
//! * [`Support`](https://github.com/paritytech/substrate/tree/master/frame/support)
//! * [`DKG Proposals`](../../pallet-dkg-proposals)
//! * [`DKG Proposal Handler`](../../pallet-dkg-proposal-handler)

#![cfg_attr(not(feature = "std"), no_std)]

use codec::Encode;
use dkg_runtime_primitives::{
	offchain::storage_keys::{
		AGGREGATED_MISBEHAVIOUR_REPORTS, AGGREGATED_MISBEHAVIOUR_REPORTS_LOCK,
		AGGREGATED_PUBLIC_KEYS, AGGREGATED_PUBLIC_KEYS_AT_GENESIS,
		AGGREGATED_PUBLIC_KEYS_AT_GENESIS_LOCK, AGGREGATED_PUBLIC_KEYS_LOCK,
		OFFCHAIN_PUBLIC_KEY_SIG, OFFCHAIN_PUBLIC_KEY_SIG_LOCK, SUBMIT_GENESIS_KEYS_AT,
		SUBMIT_KEYS_AT,
	},
	traits::{GetDKGPublicKey, OnAuthoritySetChangeHandler},
	utils::{ecdsa, to_slice_33, verify_signer_from_set_ecdsa},
	AggregatedMisbehaviourReports, AggregatedPublicKeys, AuthorityIndex, AuthoritySet,
	ConsensusLog, MisbehaviourType, RefreshProposal, RefreshProposalSigned, DKG_ENGINE_ID,
};
use frame_support::{
	dispatch::DispatchResultWithPostInfo,
	pallet_prelude::Get,
	traits::{EstimateNextSessionRotation, OneSessionHandler},
};
use frame_system::offchain::{SendSignedTransaction, Signer};
pub use pallet::*;
use sp_runtime::{
	generic::DigestItem,
	offchain::{
		storage::StorageValueRef,
		storage_lock::{StorageLock, Time},
	},
	traits::{AtLeast32BitUnsigned, Convert, IsMember, Saturating, Zero},
	DispatchError, Permill, RuntimeAppPublic,
};
use sp_std::{
	collections::btree_map::BTreeMap,
	convert::{TryFrom, TryInto},
	marker::PhantomData,
	ops::{Rem, Sub},
	prelude::*,
};
use types::RoundMetadata;
use weights::WeightInfo;

#[cfg(test)]
mod mock;
pub mod types;

#[cfg(test)]
mod tests;

#[cfg(feature = "runtime-benchmarks")]
mod benchmarking;

pub mod weights;

#[frame_support::pallet]
pub mod pallet {
	use dkg_runtime_primitives::{traits::OnDKGPublicKeyChangeHandler, ProposalHandlerTrait};
	use frame_support::{ensure, pallet_prelude::*, transactional};
	use frame_system::{
		ensure_signed,
		offchain::{AppCrypto, CreateSignedTransaction},
		pallet_prelude::*,
	};
	use log;
	use sp_runtime::{Percent, Permill};

	use super::*;

	/// A `Convert` implementation that finds the stash of the given controller account,
	/// if any.
	pub struct AuthorityIdOf<T>(sp_std::marker::PhantomData<T>);

	impl<T: Config> Convert<T::AccountId, Option<T::DKGId>> for AuthorityIdOf<T> {
		fn convert(controller: T::AccountId) -> Option<T::DKGId> {
			AccountToAuthority::<T>::get(controller)
		}
	}

	#[pallet::config]
	pub trait Config: frame_system::Config + CreateSignedTransaction<Call<Self>> {
		/// The overarching event type.
		type Event: From<Event<Self>> + IsType<<Self as frame_system::Config>::Event>;
		/// Authority identifier type
		type DKGId: Member
			+ Parameter
			+ RuntimeAppPublic
			+ MaybeSerializeDeserialize
			+ AsRef<[u8]>
			+ Into<ecdsa::Public>
			+ From<ecdsa::Public>;
		/// Jail lengths for misbehaviours
		type KeygenJailSentence: Get<Self::BlockNumber>;
		type SigningJailSentence: Get<Self::BlockNumber>;
		/// Map from controller accounts to their DKG authority identifier.
		type AuthorityIdOf: Convert<Self::AccountId, Option<Self::DKGId>>;
		/// The reputation decay percentage
		type Reputation: Member
			+ Parameter
			+ Default
			+ Encode
			+ Decode
			+ AtLeast32BitUnsigned
			+ Copy;
		/// The reputation decay percentage
		type DecayPercentage: Get<Percent>;
		/// The identifier type for an offchain worker.
		type OffChainAuthId: AppCrypto<Self::Public, Self::Signature>;

		/// Listener for authority set changes
		type OnAuthoritySetChangeHandler: OnAuthoritySetChangeHandler<
			Self::AccountId,
			dkg_runtime_primitives::AuthoritySetId,
			Self::DKGId,
		>;

		type OnDKGPublicKeyChangeHandler: OnDKGPublicKeyChangeHandler<
			dkg_runtime_primitives::AuthoritySetId,
		>;

		type ProposalHandler: ProposalHandlerTrait;

		/// A type that gives allows the pallet access to the session progress
		type NextSessionRotation: EstimateNextSessionRotation<Self::BlockNumber>;

		/// Percentage session should have progressed for refresh to begin
		#[pallet::constant]
		type RefreshDelay: Get<Permill>;

		type WeightInfo: WeightInfo;
	}

	#[pallet::pallet]
	#[pallet::generate_store(pub(super) trait Store)]
	#[pallet::without_storage_info]
	pub struct Pallet<T>(PhantomData<T>);

	#[pallet::hooks]
	impl<T: Config> Hooks<BlockNumberFor<T>> for Pallet<T> {
		fn offchain_worker(block_number: T::BlockNumber) {
			let res = Self::submit_genesis_public_key_onchain(block_number);
			log::debug!(
				target: "runtime::dkg_metadata",
				"submit_genesis_public_key_onchain : {:?}",
				res,
			);
			let res = Self::submit_next_public_key_onchain(block_number);
			log::debug!(
				target: "runtime::dkg_metadata",
				"submit_next_public_key_onchain : {:?}",
				res,
			);
			let res = Self::submit_public_key_signature_onchain(block_number);
			log::debug!(
				target: "runtime::dkg_metadata",
				"submit_public_key_signature_onchain : {:?}",
				res,
			);
			let res = Self::submit_misbehaviour_reports_onchain(block_number);
			log::debug!(
				target: "runtime::dkg_metadata",
				"submit_misbehaviour_reports_onchain : {:?}",
				res,
			);
			#[cfg(feature = "std")]
			let (authority_id, pk) = DKGPublicKey::<T>::get();
			#[cfg(feature = "std")]
			let maybe_next_key = NextDKGPublicKey::<T>::get();
			#[cfg(feature = "std")] // required since we use hex and strings
			log::debug!(
				target: "runtime::dkg_metadata",
				"Current Authority({}) DKG PublicKey:
				**********************************************************
				compressed: 0x{}
				uncompressed: 0x{}
				**********************************************************",
				authority_id,
				hex::encode(pk.clone()),
				hex::encode(Self::decompress_public_key(pk).unwrap_or_default()),
			);
			#[cfg(feature = "std")] // required since we use hex and strings
			if let Some((next_authority_id, next_pk)) = maybe_next_key {
				log::debug!(
					target: "runtime::dkg_metadata",
					"Next Authority({}) DKG PublicKey:
					**********************************************************
					compressed: 0x{}
					uncompressed: 0x{}
					**********************************************************",
					next_authority_id,
					hex::encode(next_pk.clone()),
					hex::encode(Self::decompress_public_key(next_pk).unwrap_or_default()),
				);
			}
		}

		fn on_initialize(n: BlockNumberFor<T>) -> frame_support::weights::Weight {
			if Self::should_refresh(n) && !Self::refresh_in_progress() {
				if let Some(pub_key) = Self::next_dkg_public_key() {
					RefreshInProgress::<T>::put(true);
					let uncompressed_pub_key =
						Self::decompress_public_key(pub_key.1).unwrap_or_default();
					let next_nonce = Self::refresh_nonce() + 1u32;
					let data = dkg_runtime_primitives::RefreshProposal {
						nonce: next_nonce.into(),
						pub_key: uncompressed_pub_key,
					};
					match T::ProposalHandler::handle_unsigned_refresh_proposal(data) {
						Ok(()) => {
							RefreshNonce::<T>::put(next_nonce);
							log::debug!("Handled refresh proposal");
						},
						Err(e) => {
							log::warn!("Failed to handle refresh proposal: {:?}", e);
						},
					}

					return 1
				}
			}

			0
		}
	}

	/// Public key Signatures for past sessions
	#[pallet::storage]
	#[pallet::getter(fn used_signatures)]
	pub type UsedSignatures<T: Config> = StorageValue<_, Vec<Vec<u8>>, ValueQuery>;

	/// Nonce value for next refresh proposal
	#[pallet::storage]
	#[pallet::getter(fn refresh_nonce)]
	pub type RefreshNonce<T: Config> = StorageValue<_, u32, ValueQuery>;

	/// Session progress required to kickstart refresh process
	#[pallet::storage]
	#[pallet::getter(fn refresh_delay)]
	pub type RefreshDelay<T: Config> = StorageValue<_, Permill, ValueQuery>;

	/// Check if there is a refresh in progress.
	#[pallet::storage]
	#[pallet::getter(fn refresh_in_progress)]
	pub type RefreshInProgress<T: Config> = StorageValue<_, bool, ValueQuery>;

	/// Should we manually trigger a DKG refresh process.
	#[pallet::storage]
	#[pallet::getter(fn should_manual_refresh)]
	pub type ShouldManualRefresh<T: Config> = StorageValue<_, bool, ValueQuery>;

	/// Holds public key for next session
	#[pallet::storage]
	#[pallet::getter(fn next_dkg_public_key)]
	pub type NextDKGPublicKey<T: Config> =
		StorageValue<_, (dkg_runtime_primitives::AuthoritySetId, Vec<u8>), OptionQuery>;

	/// Signature of the DKG public key for the next session
	#[pallet::storage]
	#[pallet::getter(fn next_public_key_signature)]
	pub type NextPublicKeySignature<T: Config> = StorageValue<_, Vec<u8>, OptionQuery>;

	/// Holds active public key for ongoing session
	#[pallet::storage]
	#[pallet::getter(fn dkg_public_key)]
	pub type DKGPublicKey<T: Config> =
		StorageValue<_, (dkg_runtime_primitives::AuthoritySetId, Vec<u8>), ValueQuery>;

	/// Signature of the current DKG public key
	#[pallet::storage]
	#[pallet::getter(fn public_key_signature)]
	pub type DKGPublicKeySignature<T: Config> = StorageValue<_, Vec<u8>, ValueQuery>;

	/// Holds public key for immediate past session
	#[pallet::storage]
	#[pallet::getter(fn previous_public_key)]
	pub type PreviousPublicKey<T: Config> =
		StorageValue<_, (dkg_runtime_primitives::AuthoritySetId, Vec<u8>), ValueQuery>;

	/// Tracks current proposer set
	#[pallet::storage]
	#[pallet::getter(fn historical_rounds)]
	pub type HistoricalRounds<T: Config> = StorageMap<
		_,
		Blake2_256,
		dkg_runtime_primitives::AuthoritySetId,
		RoundMetadata,
		ValueQuery,
	>;

	/// The current signature threshold (i.e. the `t` in t-of-n)
	#[pallet::storage]
	#[pallet::getter(fn signature_threshold)]
	pub(super) type SignatureThreshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	/// The current signature threshold (i.e. the `n` in t-of-n)
	#[pallet::storage]
	#[pallet::getter(fn keygen_threshold)]
	pub(super) type KeygenThreshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	/// The current signature threshold (i.e. the `t` in t-of-n)
	#[pallet::storage]
	#[pallet::getter(fn next_signature_threshold)]
	pub(super) type NextSignatureThreshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	/// The current signature threshold (i.e. the `n` in t-of-n)
	#[pallet::storage]
	#[pallet::getter(fn next_keygen_threshold)]
	pub(super) type NextKeygenThreshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	/// The pending signature threshold (i.e. the `t` in t-of-n)
	#[pallet::storage]
	#[pallet::getter(fn pending_signature_threshold)]
	pub(super) type PendingSignatureThreshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	/// The pending signature threshold (i.e. the `n` in t-of-n)
	#[pallet::storage]
	#[pallet::getter(fn pending_keygen_threshold)]
	pub(super) type PendingKeygenThreshold<T: Config> = StorageValue<_, u16, ValueQuery>;

	/// The current authorities set
	#[pallet::storage]
	#[pallet::getter(fn authorities)]
	pub(super) type Authorities<T: Config> = StorageValue<_, Vec<T::DKGId>, ValueQuery>;

	/// The current authority set id
	#[pallet::storage]
	#[pallet::getter(fn authority_set_id)]
	pub(super) type AuthoritySetId<T: Config> =
		StorageValue<_, dkg_runtime_primitives::AuthoritySetId, ValueQuery>;

	/// The next authority set id
	#[pallet::storage]
	#[pallet::getter(fn next_authority_set_id)]
	pub(super) type NextAuthoritySetId<T: Config> =
		StorageValue<_, dkg_runtime_primitives::AuthoritySetId, ValueQuery>;

	/// Authorities set scheduled to be used with the next session
	#[pallet::storage]
	#[pallet::getter(fn next_authorities)]
	pub(super) type NextAuthorities<T: Config> = StorageValue<_, Vec<T::DKGId>, ValueQuery>;

	/// Accounts for the current authorities
	#[pallet::storage]
	#[pallet::getter(fn current_authorities_accounts)]
	pub(super) type CurrentAuthoritiesAccounts<T: Config> =
		StorageValue<_, Vec<T::AccountId>, ValueQuery>;

	/// Authority account ids scheduled for the next session
	#[pallet::storage]
	#[pallet::getter(fn next_authorities_accounts)]
	pub(super) type NextAuthoritiesAccounts<T: Config> =
		StorageValue<_, Vec<T::AccountId>, ValueQuery>;

	/// Authority account ids scheduled for the next session
	#[pallet::storage]
	#[pallet::getter(fn account_to_authority)]
	pub(super) type AccountToAuthority<T: Config> =
		StorageMap<_, Blake2_256, T::AccountId, T::DKGId, OptionQuery>;

	/// Tracks misbehaviour reports
	#[pallet::storage]
	#[pallet::getter(fn misbehaviour_reports)]
	pub type MisbehaviourReports<T: Config> = StorageMap<
		_,
		Blake2_256,
		(
			dkg_runtime_primitives::MisbehaviourType,
			dkg_runtime_primitives::AuthoritySetId,
			T::DKGId,
		),
		AggregatedMisbehaviourReports<T::DKGId>,
		OptionQuery,
	>;

	/// Tracks authority reputations
	#[pallet::storage]
	#[pallet::getter(fn authority_reputations)]
	pub type AuthorityReputations<T: Config> =
		StorageMap<_, Blake2_128Concat, T::DKGId, T::Reputation, ValueQuery>;

	/// Tracks jailed authorities for keygen by mapping
	/// to the block number when the authority was last jailed
	#[pallet::storage]
	#[pallet::getter(fn jailed_keygen_authorities)]
	pub type JailedKeygenAuthorities<T: Config> =
		StorageMap<_, Blake2_256, T::DKGId, T::BlockNumber, ValueQuery>;

	/// Tracks jailed authorities for signing by mapping
	/// to the block number when the authority was last jailed
	#[pallet::storage]
	#[pallet::getter(fn jailed_signing_authorities)]
	pub type JailedSigningAuthorities<T: Config> =
		StorageMap<_, Blake2_256, T::DKGId, T::BlockNumber, ValueQuery>;

	/// The current best authorities of the active keygen set
	#[pallet::storage]
	#[pallet::getter(fn best_authorities)]
	pub(super) type BestAuthorities<T: Config> = StorageValue<_, Vec<(u16, T::DKGId)>, ValueQuery>;

	/// The next best authorities of the active keygen set
	#[pallet::storage]
	#[pallet::getter(fn next_best_authorities)]
	pub(super) type NextBestAuthorities<T: Config> =
		StorageValue<_, Vec<(u16, T::DKGId)>, ValueQuery>;

	#[pallet::genesis_config]
	pub struct GenesisConfig<T: Config> {
		pub authorities: Vec<T::DKGId>,
		pub keygen_threshold: u16,
		pub signature_threshold: u16,
		pub authority_ids: Vec<T::AccountId>,
	}

	#[pallet::error]
	pub enum Error<T> {
		/// No mapped account to authority
		NoMappedAccount,
		/// Invalid threshold
		InvalidThreshold,
		/// Must be queued  to become an authority
		MustBeAQueuedAuthority,
		/// Must be an an authority
		MustBeAnActiveAuthority,
		/// Refresh delay should be in the range of 0% - 100%
		InvalidRefreshDelay,
		/// Invalid public key submission
		InvalidPublicKeys,
		/// Already submitted a public key
		AlreadySubmittedPublicKey,
		/// Already submitted a public key signature
		AlreadySubmittedSignature,
		/// Used signature from past sessions
		UsedSignature,
		/// Invalid public key signature submission
		InvalidSignature,
		/// Invalid misbehaviour reports
		InvalidMisbehaviourReports,
		/// DKG Refresh is already in progress.
		RefreshInProgress,
		/// Manual DKG Refresh failed to progress.
		ManualRefreshFailed,
		/// No NextPublicKey stored on-chain.
		NoNextPublicKey,
		/// Must be calling from the controller account
		InvalidControllerAccount,
	}

	// Pallets use events to inform users when important changes are made.
	#[pallet::event]
	#[pallet::generate_deposit(pub fn deposit_event)]
	pub enum Event<T: Config> {
		/// Current public key submitted
		PublicKeySubmitted { compressed_pub_key: Vec<u8>, uncompressed_pub_key: Vec<u8> },
		/// Next public key submitted
		NextPublicKeySubmitted { compressed_pub_key: Vec<u8>, uncompressed_pub_key: Vec<u8> },
		/// Next public key signature submitted
		NextPublicKeySignatureSubmitted {
			pub_key_sig: Vec<u8>,
			compressed_pub_key: Vec<u8>,
			uncompressed_pub_key: Vec<u8>,
		},
		/// Current Public Key Changed.
		PublicKeyChanged { compressed_pub_key: Vec<u8>, uncompressed_pub_key: Vec<u8> },
		/// Current Public Key Signature Changed.
		PublicKeySignatureChanged {
			pub_key_sig: Vec<u8>,
			compressed_pub_key: Vec<u8>,
			uncompressed_pub_key: Vec<u8>,
		},
		/// Misbehaviour reports submitted
		MisbehaviourReportsSubmitted {
			misbehaviour_type: MisbehaviourType,
			reporters: Vec<T::DKGId>,
		},
		/// Refresh DKG Keys Finished (forcefully).
		RefreshKeysFinished { next_authority_set_id: dkg_runtime_primitives::AuthoritySetId },
		/// NextKeygenThreshold updated
		NextKeygenThresholdUpdated { next_keygen_threshold: u16 },
		/// NextSignatureThreshold updated
		NextSignatureThresholdUpdated { next_signature_threshold: u16 },
	}

	#[cfg(feature = "std")]
	impl<T: Config> Default for GenesisConfig<T> {
		fn default() -> Self {
			Self {
				authorities: Vec::new(),
				signature_threshold: 1,
				keygen_threshold: 3,
				authority_ids: Vec::new(),
			}
		}
	}

	#[pallet::genesis_build]
	impl<T: Config> GenesisBuild<T> for GenesisConfig<T> {
		fn build(&self) {
			assert!(
				self.signature_threshold < self.keygen_threshold,
				"Signature threshold must be less than keygen threshold"
			);
			assert!(self.keygen_threshold > 1, "Keygen threshold must be greater than 1");
			assert!(
				self.authority_ids.len() >= self.keygen_threshold as usize,
				"Not enough authority ids specified"
			);
			// Set thresholds to be the same
			SignatureThreshold::<T>::put(self.signature_threshold);
			KeygenThreshold::<T>::put(self.keygen_threshold);
			NextSignatureThreshold::<T>::put(self.signature_threshold);
			NextKeygenThreshold::<T>::put(self.keygen_threshold);
			PendingSignatureThreshold::<T>::put(self.signature_threshold);
			PendingKeygenThreshold::<T>::put(self.keygen_threshold);
			// Set refresh parameters
			RefreshDelay::<T>::put(T::RefreshDelay::get());
			RefreshNonce::<T>::put(0);
		}
	}

	#[pallet::call]
	impl<T: Config> Pallet<T> {
		/// Set the pending signature threshold for the session following the next session.
		///
		/// We cannot assume that the next DKG has not already completed keygen.
		/// After all, if we are in a new session the next DKG may have already completed.
		/// Therefore, when we update the thresholds we are updating a threshold
		/// that will become the next threshold after the next session update.
		///
		/// * `origin` - The account origin.
		/// * `new_threshold` - The new signature threshold for the DKG.
		#[pallet::weight(<T as Config>::WeightInfo::set_signature_threshold())]
		pub fn set_signature_threshold(
			origin: OriginFor<T>,
			new_threshold: u16,
		) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			ensure!(new_threshold > 0, Error::<T>::InvalidThreshold);
			ensure!(
				usize::from(new_threshold) < NextAuthorities::<T>::get().len(),
				Error::<T>::InvalidThreshold
			);
			PendingSignatureThreshold::<T>::try_mutate(|threshold| {
				*threshold = new_threshold;
				Ok(().into())
			})
		}

		/// Set the pending keygen threshold for the session following the next session.
		///
		/// We cannot assume that the next DKG has not already completed keygen.
		/// After all, if we are in a new session the next DKG may have already completed.
		/// Therefore, when we update the thresholds we are updating a threshold
		/// that will become the next threshold after the next session update.
		///
		/// * `origin` - The account origin.
		/// * `new_threshold` - The new keygen threshold for the DKG.
		#[transactional]
		#[pallet::weight(<T as Config>::WeightInfo::set_keygen_threshold())]
		pub fn set_keygen_threshold(
			origin: OriginFor<T>,
			new_threshold: u16,
		) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			ensure!(new_threshold > 1, Error::<T>::InvalidThreshold);
			ensure!(
				usize::from(new_threshold) <= NextAuthorities::<T>::get().len(),
				Error::<T>::InvalidThreshold
			);

			if new_threshold <= PendingSignatureThreshold::<T>::get() {
				Self::update_signature_threshold(new_threshold.saturating_sub(1))?;
			}

			Self::update_keygen_threshold(new_threshold)
		}

		/// Sets the delay when a unsigned `RefreshProposal` will be added to the unsigned
		/// proposal queue.
		///
		/// * `origin` - The account origin.
		/// * `new_delay` - The percentage of elapsed session duration to wait before adding an
		///   unsigned refresh proposal to the unsigned proposal queue.
		#[pallet::weight(<T as Config>::WeightInfo::set_refresh_delay(*new_delay as u32))]
		pub fn set_refresh_delay(
			origin: OriginFor<T>,
			new_delay: u8,
		) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;

			ensure!(new_delay <= 100, Error::<T>::InvalidRefreshDelay);

			// set the new delay
			RefreshDelay::<T>::put(Permill::from_percent(new_delay as u32));

			Ok(().into())
		}

		/// Submits and stores the active public key for the genesis session into the on-chain
		/// storage. This is primarily used to separate the genesis public key submission from
		/// non-genesis rounds.
		///
		/// Can only be submitted by the current authorities. It is also required that a
		/// `SignatureThreshold` of submissions is reached in order to successfully
		/// store the public key on-chain.
		///
		/// * `origin` - The account origin.
		/// * `keys_and_signatures` - The aggregated public keys and signatures for possible current
		///   DKG public keys.
		#[transactional]
		#[pallet::weight(<T as Config>::WeightInfo::submit_public_key(keys_and_signatures.keys_and_signatures.len() as u32))]
		pub fn submit_public_key(
			origin: OriginFor<T>,
			keys_and_signatures: AggregatedPublicKeys,
		) -> DispatchResultWithPostInfo {
			ensure_signed(origin)?;
			ensure!(!DKGPublicKey::<T>::exists(), Error::<T>::AlreadySubmittedPublicKey);

			let authorities: Vec<T::DKGId> =
				Self::best_authorities().iter().map(|id| id.1.clone()).collect();

			let dict = Self::process_public_key_submissions(keys_and_signatures, authorities);
			let threshold = Self::signature_threshold();

			let mut accepted = false;
			for (key, reporters) in dict.iter() {
				if reporters.len() > threshold.into() {
					DKGPublicKey::<T>::put((Self::authority_set_id(), key.clone()));
					Self::deposit_event(Event::PublicKeySubmitted {
						compressed_pub_key: key.clone(),
						uncompressed_pub_key: Self::decompress_public_key(key.clone())
							.unwrap_or_default(),
					});
					accepted = true;

					for authority in reporters {
						let decay: Percent = T::DecayPercentage::get();
						let reputation = AuthorityReputations::<T>::get(authority.clone());
						AuthorityReputations::<T>::insert(
							authority,
							decay.mul_floor(reputation).saturating_add(1_000_000_000u32.into()),
						);
					}

					break
				}
			}

			if accepted {
				return Ok(().into())
			}

			Err(Error::<T>::InvalidPublicKeys.into())
		}

		/// Submits and stores the next public key for the next session into the on-chain storage.
		///
		/// Can only be submitted by the next authorities. It is also required that a
		/// `NextSignatureThreshold` of submissions is reached in order to successfully
		/// store the public key on-chain.
		///
		/// * `origin` - The account origin.
		/// * `keys_and_signatures` - The aggregated public keys and signatures for possible next
		///   DKG public keys.
		#[transactional]
		#[pallet::weight(<T as Config>::WeightInfo::submit_next_public_key(keys_and_signatures.keys_and_signatures.len() as u32))]
		pub fn submit_next_public_key(
			origin: OriginFor<T>,
			keys_and_signatures: AggregatedPublicKeys,
		) -> DispatchResultWithPostInfo {
			ensure_signed(origin)?;
			ensure!(!NextDKGPublicKey::<T>::exists(), Error::<T>::AlreadySubmittedPublicKey);

			let next_authorities: Vec<T::DKGId> =
				Self::next_best_authorities().iter().map(|id| id.1.clone()).collect();
			let dict = Self::process_public_key_submissions(keys_and_signatures, next_authorities);
			let threshold = Self::next_signature_threshold();

			let mut accepted = false;
			for (key, accounts) in dict.iter() {
				if accounts.len() > threshold.into() {
					NextDKGPublicKey::<T>::put((Self::next_authority_set_id(), key.clone()));
					Self::deposit_event(Event::NextPublicKeySubmitted {
						compressed_pub_key: key.clone(),
						uncompressed_pub_key: Self::decompress_public_key(key.clone())
							.unwrap_or_default(),
					});
					accepted = true;

					break
				}
			}

			if accepted {
				// TODO Do something about accounts that posted a wrong key
				return Ok(().into())
			}

			Err(Error::<T>::InvalidPublicKeys.into())
		}

		/// Submits the public key signature for the key refresh/rotation process.
		///
		/// The signature is the signature of the next public key `RefreshProposal`, signed by the
		/// current DKG. It is stored on-chain only if it verifies successfully against the current
		/// DKG's public key. Successful storage of this public key signature also removes
		/// the unsigned `RefreshProposal` from the unsigned queue.
		///
		/// For manual refreshes, after the signature is submitted and stored on-chain,
		/// the keys are immediately refreshed and the authority set is immediately rotated
		/// and incremented.
		///
		/// * `origin` - The account origin.
		/// * `signature_proposal` - The signed refresh proposal containing the public key signature
		///   and nonce.
		#[transactional]
		#[pallet::weight(<T as Config>::WeightInfo::submit_public_key_signature())]
		pub fn submit_public_key_signature(
			origin: OriginFor<T>,
			signature_proposal: RefreshProposalSigned,
		) -> DispatchResultWithPostInfo {
			ensure_signed(origin)?;
			ensure!(Self::next_dkg_public_key().is_some(), Error::<T>::NoNextPublicKey);
			ensure!(
				Self::next_public_key_signature().is_none(),
				Error::<T>::AlreadySubmittedSignature
			);
			let used_signatures = Self::used_signatures();
			// Deconstruct the signature and nonce for easier access
			let (nonce, signature) = (signature_proposal.nonce, signature_proposal.signature);
			ensure!(
				nonce == Self::refresh_nonce().into() || !signature.is_empty(),
				Error::<T>::InvalidSignature
			);
			ensure!(!used_signatures.contains(&signature), Error::<T>::UsedSignature);

			let (_, next_pub_key) = Self::next_dkg_public_key().unwrap();
			let uncompressed_pub_key =
				Self::decompress_public_key(next_pub_key.clone()).unwrap_or_default();
			let data = RefreshProposal {
				nonce: Self::refresh_nonce().into(),
				pub_key: uncompressed_pub_key.clone(),
			};
			// Verify signature against the `RefreshProposal`
			dkg_runtime_primitives::utils::ensure_signed_by_dkg::<Self>(&signature, &data.encode())
				.map_err(|_| {
					#[cfg(feature = "std")]
					log::error!(
						target: "runtime::dkg_metadata",
						"Invalid signature for RefreshProposal
						**********************************************************
						signature: {:?}
						**********************************************************",
						hex::encode(signature.clone()),
					);
					Error::<T>::InvalidSignature
				})?;
			// Remove unsigned refresh proposal from queue
			T::ProposalHandler::handle_signed_refresh_proposal(data)?;
			NextPublicKeySignature::<T>::put(signature.clone());
			Self::deposit_event(Event::NextPublicKeySignatureSubmitted {
				uncompressed_pub_key,
				compressed_pub_key: next_pub_key,
				pub_key_sig: signature,
			});
			// Handle manual refresh if flag is set
			if Self::should_manual_refresh() {
				ShouldManualRefresh::<T>::put(false);
				let next_authorities = NextAuthorities::<T>::get();
				let next_authority_accounts = NextAuthoritiesAccounts::<T>::get();
				// Force rotate the next authorities into the active and next set.
				Self::change_authorities(
					next_authorities.clone(),
					next_authorities,
					next_authority_accounts.clone(),
					next_authority_accounts,
					true,
				);
			}

			Ok(().into())
		}

		/// Submits misbehaviour reports on chain. Signatures of the offending authority are
		/// verified against the current or next authorities depending on the type of misbehaviour.
		/// - Keygen: Verifies against the next authorities, since they are doing keygen.
		/// - Signing: Verifies against the current authorities, since they are doing signing.
		///
		/// Verifies the reports against the respective thresholds and if enough reports are met
		/// begins to jail and decrease the reputation of the offending authority.
		///
		/// The misbehaviour reputation update is:
		/// 	AUTHORITY_REPUTATION = DECAY_PERCENTAGE * AUTHORITY_REPUTATION
		///
		/// If there are not enough unjailed keygen authorities to perform a keygen after the next
		/// session, then we deduct the pending keygen threshold (and pending signing threshold)
		/// accordingly.
		///
		/// * `origin` - The account origin.
		/// * `reports` - The aggregated misbehaviour reports containing signatures of an offending
		///   authority
		#[transactional]
		#[pallet::weight(<T as Config>::WeightInfo::submit_misbehaviour_reports(reports.reporters.len() as u32))]
		pub fn submit_misbehaviour_reports(
			origin: OriginFor<T>,
			reports: AggregatedMisbehaviourReports<T::DKGId>,
		) -> DispatchResultWithPostInfo {
			ensure_signed(origin)?;
			let offender = reports.offender.clone();
			let misbehaviour_type = reports.misbehaviour_type;
			let authorities = match misbehaviour_type {
				// We assume genesis ran successfully. Therefore, keygen misbehaviours are from next
				// keygen authorities
				MisbehaviourType::Keygen => Self::next_authorities(),
				// Signing misbehaviours are from current authorities
				MisbehaviourType::Sign => Self::authorities(),
			};
			let valid_reporters = Self::process_misbehaviour_reports(reports, authorities);
			// Get the threshold for the misbehaviour type
			let signature_threshold = match misbehaviour_type {
				// Keygen misbehaviours are from next keygen authorities
				MisbehaviourType::Keygen => Self::next_signature_threshold(),
				// Signing misbehaviours are from current authorities
				MisbehaviourType::Sign => Self::signature_threshold(),
			};

			if valid_reporters.len() >= signature_threshold.into() {
				// Deduct one point for misbehaviour report
				let reputation = AuthorityReputations::<T>::get(&offender);
				// Compute reputation impact and apply to the offender
				let decay = T::DecayPercentage::get();
				AuthorityReputations::<T>::insert(&offender, decay.mul_floor(reputation));
				// Jail the respective misbehaving party depending on the misbehaviour type
				let now = frame_system::Pallet::<T>::block_number();
				match misbehaviour_type {
					MisbehaviourType::Keygen => {
						// Check if we have enough unjailed authorities to run after the next
						// session change
						let unjailed_authorities = Self::next_best_authorities()
							.into_iter()
							.filter(|(_, id)| !JailedKeygenAuthorities::<T>::contains_key(id))
							.map(|(_, id)| id)
							.collect::<Vec<T::DKGId>>();

						if unjailed_authorities.contains(&offender) {
							// Jail the offender
							JailedKeygenAuthorities::<T>::insert(&offender, now);

							// Check for authorities that are
							// 1. Not jailed
							// 2. Not already included in the next_best_authorities
							let non_jailed_non_next_best_authorities = Self::next_authorities()
								.into_iter()
								.filter(|id| !unjailed_authorities.contains(id))
								.filter(|id| !JailedKeygenAuthorities::<T>::contains_key(id))
								.collect::<Vec<T::DKGId>>();

							// If we have authorities that can take the place of the jailed
							// authority find the authority with the highest reputation to replace
							// the jailed authority
							if !non_jailed_non_next_best_authorities.is_empty() {
								let mut authorities_ordered_by_reputation =
									AuthorityReputations::<T>::iter()
										.filter(|id| {
											non_jailed_non_next_best_authorities.contains(&id.0)
										})
										.collect::<Vec<(T::DKGId, T::Reputation)>>();

								authorities_ordered_by_reputation.sort_by(|a, b| a.1.cmp(&b.1));

								// If we cannot find any authority by highest reputation
								// pick the first authority
								let highest_reputation_authority =
									if authorities_ordered_by_reputation.is_empty() {
										non_jailed_non_next_best_authorities[0].clone()
									} else {
										authorities_ordered_by_reputation.pop().unwrap().0
									};

								NextBestAuthorities::<T>::put(Self::get_best_authorities(
									Self::next_keygen_threshold() as usize,
									&unjailed_authorities
										.into_iter()
										.filter(|id| *id != offender)
										.chain(vec![highest_reputation_authority])
										.collect::<Vec<_>>(),
								));

								return Ok(().into())
							}

							// If we do not have any authorities remaining, drop the keygen
							// threshold
							if unjailed_authorities.len() <= Self::next_keygen_threshold().into() {
								// Handle edge case properly (shouldn't drop below 2 authorities)
								if unjailed_authorities.len() > 2 {
									let new_val = u16::try_from(unjailed_authorities.len() - 1)
										.unwrap_or_default();
									Self::update_next_keygen_threshold(new_val);
									PendingKeygenThreshold::<T>::put(new_val);
								}
							}
						}
						NextBestAuthorities::<T>::put(Self::get_best_authorities(
							Self::next_keygen_threshold() as usize,
							&unjailed_authorities
								.into_iter()
								.filter(|id| *id != offender)
								.collect::<Vec<_>>(),
						));
					},
					MisbehaviourType::Sign => {
						// These are the authorities who underwent keygen.
						let unjailed_authorities = Self::best_authorities()
							.into_iter()
							.filter(|(_, id)| {
								!JailedSigningAuthorities::<T>::contains_key(id) || *id != offender
							})
							.map(|(_, id)| id)
							.collect::<Vec<T::DKGId>>();
						if unjailed_authorities.len() < signature_threshold.into() {
							// Handle edge case properly (can't have -1 signers)
							if !unjailed_authorities.is_empty() {
								JailedSigningAuthorities::<T>::insert(offender, now);
								// Update the next and pending threshold
								// Since this updates the signature threshold it likely means that
								// all signing under the active DKG is failing. We have to ensure
								// that the DKG signing set contains jailed authorities in a
								// deterministic manner or expect for a forced rotation.
								let new_val = u16::try_from(unjailed_authorities.len() - 1)
									.unwrap_or_default();
								Self::update_next_signature_threshold(new_val);
								PendingSignatureThreshold::<T>::put(new_val);
							}
						} else {
							JailedSigningAuthorities::<T>::insert(offender, now)
						}
					},
				};

				Self::deposit_event(Event::MisbehaviourReportsSubmitted {
					misbehaviour_type,
					reporters: valid_reporters,
				});
				return Ok(().into())
			}

			Err(Error::<T>::InvalidMisbehaviourReports.into())
		}

		/// Attempts to remove an authority from all possible jails (keygen & signing).
		/// This can only be called by the controller of the authority in jail. The
		/// origin must map directly to the authority in jail.
		///
		/// The authority's jail sentence for either keygen or signing must be elapsed
		/// for the authority to be removed from the jail.
		///
		/// * `origin` - The account origin.
		#[pallet::weight(<T as Config>::WeightInfo::unjail())]
		pub fn unjail(origin: OriginFor<T>) -> DispatchResultWithPostInfo {
			let origin = ensure_signed(origin)?;
			let authority =
				T::AuthorityIdOf::convert(origin).ok_or(Error::<T>::InvalidControllerAccount)?;
			// TODO: Consider adding a payment to unjail similar to a slash
			if frame_system::Pallet::<T>::block_number() >
				JailedKeygenAuthorities::<T>::get(authority.clone())
					.saturating_add(T::KeygenJailSentence::get())
			{
				JailedKeygenAuthorities::<T>::remove(authority.clone());
			}

			if frame_system::Pallet::<T>::block_number() >
				JailedSigningAuthorities::<T>::get(authority.clone())
					.saturating_add(T::SigningJailSentence::get())
			{
				JailedSigningAuthorities::<T>::remove(authority);
			}
			Ok(().into())
		}

		/// Force removes an authority from keygen jail.
		///
		/// Can only be called by the root origin.
		///
		/// * `origin` - The account origin.
		/// * `authority` - The authority to be removed from the keygen jail.
		#[pallet::weight(<T as Config>::WeightInfo::force_unjail_keygen())]
		pub fn force_unjail_keygen(
			origin: OriginFor<T>,
			authority: T::DKGId,
		) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			JailedKeygenAuthorities::<T>::remove(authority);
			Ok(().into())
		}

		/// Force removes an authority from signing jail.
		///
		/// Can only be called by the root origin.
		///
		/// * `origin` - The account origin.
		/// * `authority` - The authority to be removed from the signing jail.
		#[pallet::weight(<T as Config>::WeightInfo::force_unjail_signing())]
		pub fn force_unjail_signing(
			origin: OriginFor<T>,
			authority: T::DKGId,
		) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			JailedSigningAuthorities::<T>::remove(authority);
			Ok(().into())
		}

		/// Manually Update the `RefreshNonce` (increment it by one).
		///
		/// Can only be called by the root origin.
		///
		/// * `origin` - The account origin.
		/// **Important**: This function is only available for testing purposes.
		#[pallet::weight(<T as Config>::WeightInfo::manual_increment_nonce())]
		#[transactional]
		pub fn manual_increment_nonce(origin: OriginFor<T>) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			if Self::refresh_in_progress() {
				return Err(Error::<T>::RefreshInProgress.into())
			}
			let next_nonce = Self::refresh_nonce() + 1u32;
			RefreshNonce::<T>::put(next_nonce);
			Ok(().into())
		}

		/// Manual Trigger DKG Refresh process.
		///
		/// Can only be called by the root origin.
		///
		/// * `origin` - The account that is initiating the refresh process.
		/// **Important**: This function is only available for testing purposes.
		#[pallet::weight(<T as Config>::WeightInfo::manual_refresh())]
		#[transactional]
		pub fn manual_refresh(origin: OriginFor<T>) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			if Self::refresh_in_progress() {
				return Err(Error::<T>::RefreshInProgress.into())
			}
			if let Some(pub_key) = Self::next_dkg_public_key() {
				RefreshInProgress::<T>::put(true);
				let uncompressed_pub_key = Self::decompress_public_key(pub_key.1).unwrap();
				let next_nonce = Self::refresh_nonce() + 1u32;
				let data = dkg_runtime_primitives::RefreshProposal {
					nonce: next_nonce.into(),
					pub_key: uncompressed_pub_key,
				};

				match T::ProposalHandler::handle_unsigned_refresh_proposal(data) {
					Ok(()) => {
						RefreshNonce::<T>::put(next_nonce);
						ShouldManualRefresh::<T>::put(true);
						log::debug!("Handled refresh proposal");
						Ok(().into())
					},
					Err(e) => {
						log::warn!("Failed to handle refresh proposal: {:?}", e);
						Err(Error::<T>::ManualRefreshFailed.into())
					},
				}
			} else {
				Err(Error::<T>::NoNextPublicKey.into())
			}
		}

		/// Forcefully rotate the DKG
		///
		/// This forces the next authorities into the current authority spot and
		/// automatically increments the authority ID. It uses `change_authorities`
		/// to execute the rotation forcefully.
		#[pallet::weight(0)]
		#[transactional]
		pub fn force_change_authorities(origin: OriginFor<T>) -> DispatchResultWithPostInfo {
			ensure_root(origin)?;
			let next_authorities = NextAuthorities::<T>::get();
			let next_authority_accounts = NextAuthoritiesAccounts::<T>::get();
			let next_pub_key = Self::next_dkg_public_key();
			// Force rotate the next authorities into the active and next set.
			Self::change_authorities(
				next_authorities.clone(),
				next_authorities,
				next_authority_accounts.clone(),
				next_authority_accounts,
				true,
			);
			// If there's a next key we immediately create a refresh proposal
			// to sign our own key as a means of jumpstarting the mechanism.
			if let Some(pub_key) = next_pub_key {
				RefreshInProgress::<T>::put(true);
				let uncompressed_pub_key =
					Self::decompress_public_key(pub_key.1).unwrap_or_default();
				let next_nonce = Self::refresh_nonce() + 1u32;
				let data = dkg_runtime_primitives::RefreshProposal {
					nonce: next_nonce.into(),
					pub_key: uncompressed_pub_key,
				};
				match T::ProposalHandler::handle_unsigned_refresh_proposal(data) {
					Ok(()) => {
						RefreshNonce::<T>::put(next_nonce);
						log::debug!("Handled refresh proposal");
					},
					Err(e) => {
						log::warn!("Failed to handle refresh proposal: {:?}", e);
					},
				}
			}

			Ok(().into())
		}
	}
}

impl<T: Config> Pallet<T> {
	/// Return the current active DKG authority set.
	pub fn authority_set() -> AuthoritySet<T::DKGId> {
		AuthoritySet::<T::DKGId> { authorities: Self::authorities(), id: Self::authority_set_id() }
	}

	/// Return the next DKG authority set.
	pub fn next_authority_set() -> AuthoritySet<T::DKGId> {
		AuthoritySet::<T::DKGId> {
			authorities: Self::next_authorities(),
			id: Self::next_authority_set_id(),
		}
	}

	pub fn update_signature_threshold(new_threshold: u16) -> DispatchResultWithPostInfo {
		PendingSignatureThreshold::<T>::try_mutate(|threshold| {
			*threshold = new_threshold;
			Ok(().into())
		})
	}

	pub fn update_keygen_threshold(new_threshold: u16) -> DispatchResultWithPostInfo {
		PendingKeygenThreshold::<T>::try_mutate(|threshold| {
			*threshold = new_threshold;
			Ok(().into())
		})
	}

	pub fn decompress_public_key(compressed: Vec<u8>) -> Result<Vec<u8>, DispatchError> {
		let result = libsecp256k1::PublicKey::parse_slice(
			&compressed,
			Some(libsecp256k1::PublicKeyFormat::Compressed),
		)
		.map(|pk| pk.serialize())
		.map_err(|_| Error::<T>::InvalidPublicKeys)?;
		if result.len() == 65 {
			// remove the 0x04 prefix
			Ok(result[1..].to_vec())
		} else {
			Ok(result.to_vec())
		}
	}

	pub fn process_public_key_submissions(
		aggregated_keys: AggregatedPublicKeys,
		authorities: Vec<T::DKGId>,
	) -> BTreeMap<Vec<u8>, Vec<T::DKGId>> {
		let mut dict: BTreeMap<Vec<u8>, Vec<T::DKGId>> = BTreeMap::new();

		for (pub_key, signature) in aggregated_keys.keys_and_signatures {
			let maybe_signers = authorities
				.iter()
				.map(|x| {
					ecdsa::Public(to_slice_33(&x.encode()).unwrap_or_else(|| {
						panic!("Failed to convert account id to ecdsa public key")
					}))
				})
				.collect::<Vec<ecdsa::Public>>();

			let (maybe_authority, success) =
				verify_signer_from_set_ecdsa(maybe_signers, &pub_key, &signature);

			if success {
				let authority = T::DKGId::from(maybe_authority.unwrap());
				if !dict.contains_key(&pub_key) {
					dict.insert(pub_key.clone(), Vec::new());
				}
				let temp = dict.get_mut(&pub_key).unwrap();
				if !temp.contains(&authority) {
					temp.push(authority);
				}
			}
		}

		dict
	}

	pub fn process_misbehaviour_reports(
		reports: AggregatedMisbehaviourReports<T::DKGId>,
		verifying_set: Vec<T::DKGId>,
	) -> Vec<T::DKGId> {
		let mut valid_reporters = Vec::new();
		for (inx, signature) in reports.signatures.iter().enumerate() {
			let mut signed_payload = Vec::new();
			signed_payload.extend_from_slice(&match reports.misbehaviour_type {
				MisbehaviourType::Keygen => [0x01],
				MisbehaviourType::Sign => [0x02],
			});
			signed_payload.extend_from_slice(reports.round_id.to_be_bytes().as_ref());
			signed_payload.extend_from_slice(reports.offender.as_ref());

			// TODO: Verify signer from set over the best authorities set (compute it on chain)
			let verifying_set: Vec<ecdsa::Public> = verifying_set
				.iter()
				.map(|x| ecdsa::Public(to_slice_33(&x.encode()).unwrap_or([0u8; 33])))
				.collect();
			let (_, success) =
				verify_signer_from_set_ecdsa(verifying_set, &signed_payload, signature);

			if success && !valid_reporters.contains(&reports.reporters[inx]) {
				valid_reporters.push(reports.reporters[inx].clone());
			}
		}

		valid_reporters
	}

	pub fn store_consensus_log(
		authority_ids: Vec<T::DKGId>,
		next_authority_ids: Vec<T::DKGId>,
		active_set_id: dkg_runtime_primitives::AuthoritySetId,
	) {
		let log: DigestItem = DigestItem::Consensus(
			DKG_ENGINE_ID,
			ConsensusLog::AuthoritiesChange {
				active: AuthoritySet { authorities: authority_ids, id: active_set_id },
				queued: AuthoritySet {
					authorities: next_authority_ids,
					id: active_set_id.saturating_add(1),
				},
			}
			.encode(),
		);
		<frame_system::Pallet<T>>::deposit_log(log);
	}

	/// Change the current DKG authority set by rotating to the `new_authority_ids` set.
	///
	/// This function is meant to be called on a new session when the next authorities
	/// become the current or `new` authorities. We track the accounts for these
	/// authorities as well.
	fn change_authorities(
		new_authority_ids: Vec<T::DKGId>,
		next_authority_ids: Vec<T::DKGId>,
		new_authorities_accounts: Vec<T::AccountId>,
		next_authorities_accounts: Vec<T::AccountId>,
		forced: bool,
	) {
		// Call set change handler to trigger the other pallet implementing this hook
		<T::OnAuthoritySetChangeHandler as OnAuthoritySetChangeHandler<
			T::AccountId,
			dkg_runtime_primitives::AuthoritySetId,
			T::DKGId,
		>>::on_authority_set_changed(new_authorities_accounts.clone(), new_authority_ids.clone());
		// Set refresh in progress to false
		RefreshInProgress::<T>::put(false);
		// Update the next thresholds for the next session
		let new_current_signature_threshold = NextSignatureThreshold::<T>::get();
		let new_current_keygen_threshold = NextKeygenThreshold::<T>::get();
		Self::update_next_signature_threshold(PendingSignatureThreshold::<T>::get());
		Self::update_next_keygen_threshold(PendingKeygenThreshold::<T>::get());
		// Compute next ID for next authorities
		let next_id = Self::next_authority_set_id();
		// We continue to rotate the next authority set in case of failure of the previous
		// next authorities to generate a key, thus preventing a signature from being produced.
		NextAuthorities::<T>::put(&next_authority_ids);
		NextAuthoritiesAccounts::<T>::put(&next_authorities_accounts);
		NextAuthoritySetId::<T>::put(next_id.saturating_add(1));
		let new_best_authorities = Self::next_best_authorities();
		// Update the keys for the next authorities
		let next_pub_key = Self::next_dkg_public_key();
		let next_pub_key_signature = Self::next_public_key_signature();
		let dkg_pub_key = Self::dkg_public_key();
		let pub_key_signature = Self::public_key_signature();
		// Ensure next/pending thresholds remain valid across authority set changes that may
		// break. We update the pending thresholds because we call `refresh_keys` below, which
		// rotates all the thresholds into the current / next sets. Pending becomes the next,
		// next becomes the current.
		if next_authority_ids.len() < Self::next_keygen_threshold().into() {
			Self::update_next_keygen_threshold(next_authority_ids.len() as u16);
			PendingKeygenThreshold::<T>::put(next_authority_ids.len() as u16);
		}
		if next_authority_ids.len() <= Self::next_signature_threshold().into() {
			Self::update_next_signature_threshold(next_authority_ids.len() as u16 - 1);
			PendingSignatureThreshold::<T>::put(next_authority_ids.len() as u16 - 1);
		}
		// Update the next best authorities after any and all changes to the thresholds.
		NextBestAuthorities::<T>::put(Self::get_best_authorities(
			Self::next_keygen_threshold() as usize,
			&next_authority_ids,
		));
		// Switch on forced for forceful rotations
		let v = if forced {
			// If forced we supply an empty signature
			next_pub_key.zip(Some(vec![]))
		} else {
			next_pub_key.zip(next_pub_key_signature)
		};
		// Rotate the authority set if a next pub key and next signature exist
		if let Some((next_pub_key, next_pub_key_signature)) = v {
			// Update the active thresholds for the next session
			SignatureThreshold::<T>::put(new_current_signature_threshold);
			KeygenThreshold::<T>::put(new_current_keygen_threshold);
			// Update the new and next authorities
			Authorities::<T>::put(&new_authority_ids);
			CurrentAuthoritiesAccounts::<T>::put(&new_authorities_accounts);
			BestAuthorities::<T>::put(new_best_authorities);
			// Update the set id after changing
			AuthoritySetId::<T>::put(next_id);
			// Deposit a consensus log about the authority set change
			Self::store_consensus_log(new_authority_ids, next_authority_ids, next_id);
			// Delete next records
			NextDKGPublicKey::<T>::kill();
			NextPublicKeySignature::<T>::kill();
			// Record historical refresh record
			Self::insert_historical_refresh(&dkg_pub_key, &next_pub_key, &next_pub_key_signature);
			// Set new keys
			DKGPublicKey::<T>::put(next_pub_key.clone());
			DKGPublicKeySignature::<T>::put(next_pub_key_signature.clone());
			PreviousPublicKey::<T>::put(dkg_pub_key);
			UsedSignatures::<T>::mutate(|val| {
				val.push(pub_key_signature.clone());
			});
			let uncompressed_pub_key =
				Self::decompress_public_key(next_pub_key.1.clone()).unwrap_or_default();
			let compressed_pub_key = next_pub_key.1;

			// Emit events so other front-end know that.
			Self::deposit_event(Event::PublicKeyChanged {
				uncompressed_pub_key: uncompressed_pub_key.clone(),
				compressed_pub_key: compressed_pub_key.clone(),
			});
			Self::deposit_event(Event::PublicKeySignatureChanged {
				uncompressed_pub_key,
				compressed_pub_key,
				pub_key_sig: next_pub_key_signature,
			});
		}
	}

	/// Initializes the storage values for authorities and their accounts
	/// on a genesis session and triggers the first authority set change.
	fn initialize_authorities(authorities: &[T::DKGId], authority_account_ids: &[T::AccountId]) {
		if authorities.is_empty() {
			log::warn!(
				target: "runtime::dkg_metadata",
				"trying to intialize the autorities with empty list!",
			);
			return
		}
		log::debug!(
			target: "runtime::dkg_metadata",
			"intializing the authorities with: {:?} and account ids: {:?}",
			authorities,
			authority_account_ids,
		);
		assert!(Authorities::<T>::get().is_empty(), "Authorities are already initialized!");
		// Initialize current authorities
		Authorities::<T>::put(authorities);
		AuthoritySetId::<T>::put(0);
		CurrentAuthoritiesAccounts::<T>::put(authority_account_ids);
		// Initialize next authorities
		NextAuthorities::<T>::put(authorities);
		NextAuthoritySetId::<T>::put(1);
		NextAuthoritiesAccounts::<T>::put(authority_account_ids);
		let best_authorities =
			Self::get_best_authorities(Self::keygen_threshold() as usize, authorities);
		log::debug!(
			target: "runtime::dkg_metadata",
			"best_authorities: {:?}",
			best_authorities,
		);
		BestAuthorities::<T>::put(best_authorities);
		let next_best_authorities =
			Self::get_best_authorities(Self::keygen_threshold() as usize, authorities);
		NextBestAuthorities::<T>::put(next_best_authorities);

		<T::OnAuthoritySetChangeHandler as OnAuthoritySetChangeHandler<
			T::AccountId,
			dkg_runtime_primitives::AuthoritySetId,
			T::DKGId,
		>>::on_authority_set_changed(authority_account_ids.to_vec(), authorities.to_vec());
	}

	/// An offchain function that collects the genesis DKG public key
	/// and submits it to the chain.
	///
	/// This submission process is modelled similarly after an oracle.
	/// We require the respective threshold of submissions of the same
	/// DKG public key to be submitted in order to modify the on-chain
	/// storage.
	fn submit_genesis_public_key_onchain(block_number: T::BlockNumber) -> Result<(), &'static str> {
		let mut lock = StorageLock::<Time>::new(AGGREGATED_PUBLIC_KEYS_AT_GENESIS_LOCK);
		{
			let _guard = lock.lock();
			let mut agg_key_ref = StorageValueRef::persistent(AGGREGATED_PUBLIC_KEYS_AT_GENESIS);
			let mut submit_at_ref = StorageValueRef::persistent(SUBMIT_GENESIS_KEYS_AT);
			const RECENTLY_SENT: &str = "Already submitted a key in this session";
			let submit_at = submit_at_ref.get::<T::BlockNumber>();

			let agg_keys = agg_key_ref.get::<AggregatedPublicKeys>();

			if let Ok(None) = agg_keys {
				return Ok(())
			}

			if let Ok(Some(submit_at)) = submit_at {
				if block_number < submit_at {
					log::debug!(target: "runtime::dkg_metadata", "Offchain worker skipping public key submmission");
					return Ok(())
				} else {
					submit_at_ref.clear();
				}
			} else {
				return Err(RECENTLY_SENT)
			}

			if !Self::dkg_public_key().1.is_empty() {
				agg_key_ref.clear();
				return Ok(())
			}

			let signer = Signer::<T, T::OffChainAuthId>::all_accounts();
			if !signer.can_sign() {
				return Err(
					"No local accounts available. Consider adding one via `author_insertKey` RPC.",
				)
			}

			if let Ok(Some(agg_keys)) = agg_keys {
				let _res = signer.send_signed_transaction(|_account| Call::submit_public_key {
					keys_and_signatures: agg_keys.clone(),
				});
				agg_key_ref.clear();
			}

			Ok(())
		}
	}

	/// An offchain function that collects the next DKG public key
	/// and submits it to the chain.
	///
	/// This submission process is modelled similarly after an oracle.
	/// We require the respective threshold of submissions of the same
	/// DKG public key to be submitted in order to modify the on-chain
	/// storage.
	fn submit_next_public_key_onchain(block_number: T::BlockNumber) -> Result<(), &'static str> {
		let mut lock = StorageLock::<Time>::new(AGGREGATED_PUBLIC_KEYS_LOCK);
		{
			let _guard = lock.lock();

			let mut agg_key_ref = StorageValueRef::persistent(AGGREGATED_PUBLIC_KEYS);
			let mut submit_at_ref = StorageValueRef::persistent(SUBMIT_KEYS_AT);
			const RECENTLY_SENT: &str = "Already submitted a key in this session";
			let submit_at = submit_at_ref.get::<T::BlockNumber>();

			let agg_keys = agg_key_ref.get::<AggregatedPublicKeys>();

			if let Ok(None) = agg_keys {
				return Ok(())
			}

			if let Ok(Some(submit_at)) = submit_at {
				if block_number < submit_at {
					log::debug!(target: "runtime::dkg_metadata", "Offchain worker skipping next public key submmission");
					return Ok(())
				} else {
					submit_at_ref.clear();
				}
			} else {
				return Err(RECENTLY_SENT)
			}

			if Self::next_dkg_public_key().is_some() {
				agg_key_ref.clear();
				return Ok(())
			}

			let signer = Signer::<T, T::OffChainAuthId>::all_accounts();
			if !signer.can_sign() {
				return Err(
					"No local accounts available. Consider adding one via `author_insertKey` RPC.",
				)
			}

			if let Ok(Some(agg_keys)) = agg_keys {
				let res = signer.send_signed_transaction(|_account| Call::submit_next_public_key {
					keys_and_signatures: agg_keys.clone(),
				});

				if Self::process_send_signed_transaction_result(res).is_ok() {
					log::debug!(target: "runtime::dkg_metadata", "Offchain submitting next public key sig onchain SUCCEEDED{:?}", agg_keys);
				} else {
					log::debug!(target: "runtime::dkg_metadata", "Offchain submitting next public key sig onchain FAILED {:?}", agg_keys);
				}

				agg_key_ref.clear();
			}

			Ok(())
		}
	}

	/// An offchain function that collects the next DKG public key
	/// signature and submits it to the chain.
	fn submit_public_key_signature_onchain(
		_block_number: T::BlockNumber,
	) -> Result<(), &'static str> {
		let mut lock = StorageLock::<Time>::new(OFFCHAIN_PUBLIC_KEY_SIG_LOCK);
		{
			let _guard = lock.lock();

			let mut pub_key_sig_ref = StorageValueRef::persistent(OFFCHAIN_PUBLIC_KEY_SIG);

			if Self::next_public_key_signature().is_some() {
				pub_key_sig_ref.clear();
				return Ok(())
			}

			let refresh_proposal = pub_key_sig_ref.get::<RefreshProposalSigned>();

			let signer = Signer::<T, T::OffChainAuthId>::all_accounts();
			if !signer.can_sign() {
				return Err(
					"No local accounts available. Consider adding one via `author_insertKey` RPC.",
				)
			}

			if let Ok(Some(refresh_proposal)) = refresh_proposal {
				let res =
					signer.send_signed_transaction(|_account| Call::submit_public_key_signature {
						signature_proposal: refresh_proposal.clone(),
					});

				if Self::process_send_signed_transaction_result(res).is_ok() {
					log::debug!(target: "runtime::dkg_metadata", "Offchain submitting public key sig onchain SUCCEEDED{:?}", refresh_proposal.signature);
				} else {
					log::debug!(target: "runtime::dkg_metadata", "Offchain submitting public key sig onchain FAILED {:?}", refresh_proposal.signature);
				}

				pub_key_sig_ref.clear();
			}

			Ok(())
		}
	}

	/// An offchain function that collects the misbehaviour reports in
	/// the offchain storage and submits them to the chain.
	fn submit_misbehaviour_reports_onchain(
		_block_number: T::BlockNumber,
	) -> Result<(), &'static str> {
		let mut lock = StorageLock::<Time>::new(AGGREGATED_MISBEHAVIOUR_REPORTS_LOCK);
		{
			let _guard = lock.lock();

			let signer = Signer::<T, T::OffChainAuthId>::all_accounts();
			if !signer.can_sign() {
				return Err(
					"No local accounts available. Consider adding one via `author_insertKey` RPC.",
				)
			}

			let mut agg_reports_ref = StorageValueRef::persistent(AGGREGATED_MISBEHAVIOUR_REPORTS);
			let agg_misbehaviour_reports =
				agg_reports_ref.get::<AggregatedMisbehaviourReports<T::DKGId>>();

			if let Ok(Some(reports)) = agg_misbehaviour_reports {
				// If this offender has already been reported, don't report it again.
				if Self::misbehaviour_reports((
					reports.misbehaviour_type,
					reports.round_id,
					reports.offender.clone(),
				))
				.is_some()
				{
					agg_reports_ref.clear();
					return Ok(())
				}

				let res = signer.send_signed_transaction(|_account| {
					Call::submit_misbehaviour_reports { reports: reports.clone() }
				});

				if Self::process_send_signed_transaction_result(res).is_ok() {
					log::info!(target: "runtime::dkg_metadata", "Offchain submitting misbehaviour reports onchain SUCCEEDED {:?}", reports);
					// clear storage since we successfuly reported
					agg_reports_ref.clear();
				} else {
					log::debug!(target: "runtime::dkg_metadata", "Offchain submitting misbehaviour reports onchain FAILED {:?}", reports);
				}
			}

			Ok(())
		}
	}

	pub fn update_next_keygen_threshold(next_threshold: u16) {
		let current_next_keygen_threshold = Self::next_keygen_threshold();
		if current_next_keygen_threshold != next_threshold {
			NextKeygenThreshold::<T>::put(next_threshold);
			Self::deposit_event(Event::NextKeygenThresholdUpdated {
				next_keygen_threshold: next_threshold,
			});
		}
	}

	#[allow(clippy::unit_arg)]
	pub fn process_send_signed_transaction_result(
		results: Vec<(frame_system::offchain::Account<T>, Result<(), ()>)>,
	) -> Result<(), ()> {
		for (_acc, res) in &results {
			match res {
				Ok(()) => {},
				Err(e) => return Err(*e),
			}
		}
		// transaction submitted succesfully
		Ok(())
	}

	pub fn update_next_signature_threshold(next_threshold: u16) {
		let current_next_signature_threshold = Self::next_signature_threshold();
		if current_next_signature_threshold != next_threshold {
			NextSignatureThreshold::<T>::put(next_threshold);
			Self::deposit_event(Event::NextSignatureThresholdUpdated {
				next_signature_threshold: next_threshold,
			});
		}
	}

	/// Identifies if a new `RefreshProposal` should be created
	/// at a given block number. This is meant to be called on the
	/// `on_initialize` hook at every block to check if we should begin
	/// the refresh proposal signing process.
	pub fn should_refresh(now: T::BlockNumber) -> bool {
		let (session_progress, ..) = <T::NextSessionRotation as EstimateNextSessionRotation<
			T::BlockNumber,
		>>::estimate_current_session_progress(now);
		log::debug!(target: "runtime::dkg_metadata", "SHOULD_REFRESH : Session progress", session_progress);
		if let Some(session_progress) = session_progress {
			let delay = RefreshDelay::<T>::get();
			let next_dkg_public_key_signature = Self::next_public_key_signature();
			return (delay <= session_progress) && next_dkg_public_key_signature.is_none()
		}

		log::debug!(target: "runtime::dkg_metadata", "Unable to read session progress");
		false
	}

	/// Inserts a successful rotation into the history
	///
	/// Insert historical round metadata consisting of the current round's
	/// public key before rotation, the next round's public key, and the refresh
	/// signature signed by the current key refreshing the next.
	pub fn insert_historical_refresh(
		dkg_pub_key: &(dkg_runtime_primitives::AuthoritySetId, Vec<u8>),
		next_pub_key: &(dkg_runtime_primitives::AuthoritySetId, Vec<u8>),
		next_pub_key_signature: &[u8],
	) {
		HistoricalRounds::<T>::insert(
			next_pub_key.0,
			RoundMetadata {
				curr_round_pub_key: dkg_pub_key.1.clone(),
				next_round_pub_key: next_pub_key.clone().1,
				refresh_signature: next_pub_key_signature.to_vec(),
			},
		);
	}

	pub fn max_extrinsic_delay(_block_number: T::BlockNumber) -> T::BlockNumber {
		let refresh_delay = Self::refresh_delay();
		let session_length = <T::NextSessionRotation as EstimateNextSessionRotation<
			T::BlockNumber,
		>>::average_session_length();

		Permill::from_percent(50) * (refresh_delay * session_length)
	}

	pub fn get_best_authorities_by_reputation(
		count: usize,
		authorities: &[T::DKGId],
	) -> Vec<(u16, T::DKGId)> {
		let mut reputations_of_authorities = authorities
			.iter()
			.map(|id| (AuthorityReputations::<T>::get(id), id))
			.collect::<Vec<(_, _)>>();
		reputations_of_authorities.sort_by(|a, b| b.0.cmp(&a.0));

		return reputations_of_authorities
			.iter()
			.take(count)
			.cloned()
			.enumerate()
			.map(|(i, (_, id))| ((i + 1) as u16, id.clone()))
			.collect()
	}

	pub fn get_best_authorities(count: usize, authorities: &[T::DKGId]) -> Vec<(u16, T::DKGId)> {
		let jailed_authorities = authorities
			.iter()
			.cloned()
			.filter(|id| JailedKeygenAuthorities::<T>::contains_key(id))
			.collect::<Vec<T::DKGId>>();
		let mut best_authorities = authorities
			.iter()
			.cloned()
			.filter(|id| !JailedKeygenAuthorities::<T>::contains_key(id))
			.collect::<Vec<T::DKGId>>();
		if best_authorities.len() < count {
			let best_jailed = Self::get_best_authorities_by_reputation(
				count - best_authorities.len(),
				&jailed_authorities,
			);
			best_authorities.extend(best_jailed.iter().map(|x| x.1.clone()));
		}
		Self::get_best_authorities_by_reputation(count, &best_authorities)
	}

	#[cfg(feature = "runtime-benchmarks")]
	pub fn set_dkg_public_key(key: Vec<u8>) {
		DKGPublicKey::<T>::put((0, key))
	}
}

impl<T: Config> sp_runtime::BoundToRuntimeAppPublic for Pallet<T> {
	type Public = T::DKGId;
}

impl<T: Config> OneSessionHandler<T::AccountId> for Pallet<T> {
	type Key = T::DKGId;

	fn on_genesis_session<'a, I: 'a>(validators: I)
	where
		I: Iterator<Item = (&'a T::AccountId, T::DKGId)>,
	{
		log::debug!(target: "runtime::dkg_metadata", "on_genesis_session");
		let mut authority_account_ids = Vec::new();
		let authorities = validators
			.map(|(l, k)| {
				authority_account_ids.push(l.clone());
				k
			})
			.collect::<Vec<_>>();

		Self::initialize_authorities(&authorities, &authority_account_ids);
	}

	// We want to run this function always because there are other factors (forcing a new era) that
	// can affect changes to the queued validator set that the session pallet will not take not of
	// until the next session, and this could cause the value of `changed` to be wrong, causing an
	// out of sync between this pallet and the session pallet. The `changed` value is true most of
	// the times except in rare cases, omitting  that check does not cause any harm, since this
	// function is light weight we already have a check in the change_authorities function that
	// would ensure the refresh is not run if the authority set has not changed.
	fn on_new_session<'a, I: 'a>(_changed: bool, validators: I, queued_validators: I)
	where
		I: Iterator<Item = (&'a T::AccountId, T::DKGId)>,
	{
		let mut authority_account_ids = Vec::new();
		let mut queued_authority_account_ids = Vec::new();
		let next_authorities = validators
			.map(|(acc, k)| {
				authority_account_ids.push(acc.clone());
				AccountToAuthority::<T>::insert(&acc, k.clone());
				k
			})
			.collect::<Vec<_>>();

		let next_queued_authorities = queued_validators
			.map(|(acc, k)| {
				queued_authority_account_ids.push(acc.clone());
				AccountToAuthority::<T>::insert(&acc, k.clone());
				k
			})
			.collect::<Vec<_>>();

		Self::change_authorities(
			next_authorities,
			next_queued_authorities,
			authority_account_ids,
			queued_authority_account_ids,
			false,
		);
	}

	fn on_disabled(i: u32) {
		let log: DigestItem = DigestItem::Consensus(
			DKG_ENGINE_ID,
			ConsensusLog::<T::DKGId>::OnDisabled(i as AuthorityIndex).encode(),
		);

		<frame_system::Pallet<T>>::deposit_log(log);
	}
}

impl<T: Config> IsMember<T::DKGId> for Pallet<T> {
	fn is_member(authority_id: &T::DKGId) -> bool {
		Self::authorities().iter().any(|id| id == authority_id)
	}
}

impl<T: Config> GetDKGPublicKey for Pallet<T> {
	fn dkg_key() -> Vec<u8> {
		Self::dkg_public_key().1
	}

	fn previous_dkg_key() -> Vec<u8> {
		Self::previous_public_key().1
	}
}

/// Periodic Session manager for DKGMetadata
/// To rotate a session we require three conditions
/// 1. The Period has passed
/// 2. The NextDKGPublicKey has been set on chain
/// 3. The NextPublicKeySignature has been set onchain
pub struct DKGPeriodicSessions<Period, Offset, T>(PhantomData<(Period, Offset, T)>);

impl<
		BlockNumber: Rem<Output = BlockNumber> + Sub<Output = BlockNumber> + Zero + PartialOrd,
		Period: Get<BlockNumber>,
		Offset: Get<BlockNumber>,
		T: Config,
	> pallet_session::ShouldEndSession<BlockNumber> for DKGPeriodicSessions<Period, Offset, T>
{
	fn should_end_session(now: BlockNumber) -> bool {
		// The succesful upload of the new public key is required for a successful rotation we check
		// if the nextPublicKey and nextPublicKeySignature are stored onchain.
		let offset = Offset::get();
		let next_public_key_exists = NextDKGPublicKey::<T>::get().is_some();
		let next_public_key_signature_exists = NextPublicKeySignature::<T>::get().is_some();
		next_public_key_exists &&
			next_public_key_signature_exists &&
			now >= offset &&
			((now - offset) % Period::get()) >= Zero::zero()
	}
}
